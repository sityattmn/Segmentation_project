# -*- coding: utf-8 -*-"""Created on Wed Jul  10 11:12:12 2023@author: S.Mouhamadi"""from skimage import filters, feature, segmentation, exposureimport bm4dimport numpy as npimport scipy.io as spimport matplotlib.pyplot as pltdef do_bm4d_gauss_filter(mat_file_path):    # Load the MATLAB file    mat_data = sp.loadmat(mat_file_path)    image_data = np.abs(mat_data['image3D'])  # Update the indexing here    image_data = image_data.astype(np.float64)    # Estimate the noise level using the MAD method and Universal Thresholding    med = np.median(image_data)    mad = np.median(np.abs(image_data - med))    noise = 1.4826 * mad    sigma_psd = noise / np.sqrt(2 * np.log(image_data.size))        # Estimate the noise level using the Histogram method    # histogram, bins = np.histogram(image_data.flatten(), bins='auto')    # bin_centers = (bins[:-1] + bins[1:]) / 2    # background_hist = histogram[:int(len(histogram) * 0.1)]  #select the noisy part or the histogramm    # fit_params = np.polyfit(bin_centers[:len(background_hist)], np.log(background_hist), deg=1)    # sigma_psd = np.sqrt(-1 / fit_params[0])    profile = bm4d.BM4DProfile()  # Default profile    stage_arg = bm4d.BM4DStages.ALL_STAGES  # Perform both hard thresholding and Wiener filtering    blockmatches = (False, False)  # Do not use previous blockmatches    # Apply BM4D to the image    denoised_image = bm4d.bm4d(image_data, sigma_psd=sigma_psd, profile=profile, stage_arg=stage_arg, blockmatches=blockmatches)    # Update the filtered image in the MATLAB file    mat_data['imageDenoised'] = denoised_image    # Save the filtered MATLAB file    sp.savemat(mat_file_path, mat_data)        # Store the original image and the denoised image    original_image = np.abs(mat_data['image3D'])    denoised_image = np.abs(mat_data['imageDenoised'])    return mat_data, original_image, denoised_imagemat_file_path ="C:/Users/Portatil PC 7/Documents/Data/Calves_ImageD/RAREprotocols_T1_TRA.2023.05.11.12.47.42.304_ImageD.mat"mat_data, original_image, denoised_image = do_bm4d_gauss_filter(mat_file_path)slice_index = 13  # Modify this to the desired slice indexnormalized_image_ = exposure.rescale_intensity(original_image[slice_index, :, :])image_edges_ = feature.canny(normalized_image_, sigma=0.1)marked_original = segmentation.mark_boundaries(normalized_image_, image_edges_)normalized_image = exposure.rescale_intensity(denoised_image[slice_index, :, :])image_edges = feature.canny(normalized_image, sigma=0.1)marked_denoised = segmentation.mark_boundaries(normalized_image, image_edges)plt.subplot(2, 2, 1)plt.imshow(original_image[slice_index,:,:], cmap='gray')plt.title(f'Original Image (Slice {slice_index+1})')plt.subplot(2, 2, 2)plt.imshow(denoised_image[slice_index,:,:], cmap='gray')plt.title(f'Denoised Image (Slice {slice_index+1})')plt.subplot(2, 2, 3)plt.imshow(marked_original, cmap='gray')plt.title(f'Contour Detection - Denoised Image (Slice {slice_index+1})')plt.subplot(2, 2, 4)plt.imshow(marked_denoised, cmap='gray')plt.title(f'Contour Detection - Original Image (Slice {slice_index+1})')plt.show()